/*
Dakari Lanes
Edwin Culpepper
COMP 360
Project 1 Lexicon
9/24/25
*/


import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Arrays;

// Token types
enum TokenType {
    KEYWORD, IDENTIFIER, OPERATOR, DELIMITER, NUMBER, WHITESPACE, UNKNOWN
}

// Token class to store token type and value
class Token {
    TokenType type;
    String value;

    public Token(TokenType type, String value) {
        this.type = type;
        this.value = value;
    }

    @Override
    public String toString() {
        return "(" + type.ordinal() + ", " + value + ")";
    }
}

// Lexical analyzer
class LexicalAnalyzer {
    public static List<Token> analyze(String sourceCode) {
        List<Token> tokens = new ArrayList<>();
        List<String[]> tokenPatterns = Arrays.asList(
                new String[]{TokenType.KEYWORD.name(), "(int|while|void)"},
                new String[]{TokenType.IDENTIFIER.name(), "[a-z][a-z0-9]*"},
                new String[]{TokenType.OPERATOR.name(), "(<=|>=|\\+|=)"},
                new String[]{TokenType.DELIMITER.name(), "[();{},]"},
                new String[]{TokenType.NUMBER.name(), "(100|20)"},
                new String[]{TokenType.WHITESPACE.name(), "\\s+"}
        );

        String remainingCode = sourceCode;
        while (!remainingCode.isEmpty()) {
            boolean matched = false;
            for (String[] pattern : tokenPatterns) {
                Pattern regex = Pattern.compile("^(" + pattern[1] + ")");
                Matcher matcher = regex.matcher(remainingCode);
                if (matcher.find()) {
                    String value = matcher.group(1).trim();
                    if (!pattern[0].equals(TokenType.WHITESPACE.name())) {
                        tokens.add(new Token(TokenType.valueOf(pattern[0]), value));
                    }
                    remainingCode = remainingCode.substring(matcher.end());
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                throw new RuntimeException("Unknown token: " + remainingCode.charAt(0));
            }
        }
        return tokens;
    }
}

// Recursive-descent parser
class Parser {
    private List<Token> tokens;
    private int currentTokenIndex;

    public Parser(List<Token> tokens) {
        this.tokens = tokens;
        this.currentTokenIndex = 0;
    }

    private Token currentToken() {
        if (currentTokenIndex < tokens.size()) {
            return tokens.get(currentTokenIndex);
        }
        return new Token(TokenType.UNKNOWN, "");
    }

    private void match(TokenType expectedType, String expectedValue) {
        Token token = currentToken();
        if (token.type == expectedType && (expectedValue.isEmpty() || token.value.equals(expectedValue))) {
            currentTokenIndex++;
        } else {
            throw new RuntimeException("expected " + expectedValue + ", but found " + token.value);
        }
    }

    private void match(TokenType expectedType) {
        match(expectedType, "");
    }

    private void program() {
        keyword("void");
        ident();
        match(TokenType.DELIMITER, "(");
        match(TokenType.DELIMITER, ")");
        match(TokenType.DELIMITER, "{");
        declares();
        loop();
        assignment();
        match(TokenType.DELIMITER, "}");
    }

    private void declares() {
        keyword("int");
        ident();
        match(TokenType.OPERATOR, "=");
        constValue();
        match(TokenType.DELIMITER, ";");
    }

    private void loop() {
        keyword("while");
        match(TokenType.DELIMITER, "(");
        ident();
        match(TokenType.OPERATOR, "<=");
        constValue();
        match(TokenType.DELIMITER, ")");
    }

    private void assignment() {
        ident();
        match(TokenType.OPERATOR, "=");
        ident();
        match(TokenType.OPERATOR, "+");
        ident();
        match(TokenType.DELIMITER, ";");
    }

    private void keyword(String value) {
        match(TokenType.KEYWORD, value);
    }

    private void constValue() {
        match(TokenType.NUMBER);
    }

    private void ident() {
        match(TokenType.IDENTIFIER);
    }

    public void parse() {
        try {
            program();
            if (currentToken().type != TokenType.UNKNOWN) {
                throw new RuntimeException("Unexpected token at the end of input: " + currentToken().value);
            }
            System.out.println("The Test Source Code is generated by the grammar.");
        } catch (RuntimeException e) {
            System.out.println("The Test Source Code cannot be generated by the Project1 EBNF Defined Language, and " + e.getMessage() + ".");
        }
    }
}

// Main class to run the program
public class project1 {
    public static void main(String[] args) {
        // Test Source Code 1
        String sourceCode1 = "void try (){int data = 20; while (data <= 100 )data = data + data;}";

        // Test Source Code 2
        String sourceCode2 = "void mul (int data) {data = data + number;}";

        // Run the tests
        System.out.println("Testing Test Source Code 1:");
        test(sourceCode1);

        System.out.println("\nTesting Test Source Code 2:");
        test(sourceCode2);
    }

    private static void test(String sourceCode) {
        try {
            List<Token> tokens = LexicalAnalyzer.analyze(sourceCode);
            System.out.print("Tokens: ");
            for (Token token : tokens) {
                System.out.print(token + " ");
            }
            System.out.println();
            Parser parser = new Parser(tokens);
            parser.parse();
        } catch (RuntimeException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}
